# SONAR Deployment Guide

This guide covers deploying the SONAR backend to Railway and verifying the full stack integration.

## Table of Contents

1. [Prerequisites](#prerequisites)
2. [Local Testing](#local-testing)
3. [Railway Deployment](#railway-deployment)
4. [Environment Configuration](#environment-configuration)
5. [Database Setup](#database-setup)
6. [Post-Deployment Verification](#post-deployment-verification)
7. [Troubleshooting](#troubleshooting)

## Prerequisites

- [Railway CLI](https://railway.app/guide) installed and authenticated
- [Bun](https://bun.sh) installed locally
- Docker (for local testing)
- PostgreSQL 14+ (for local development)
- Git repository initialized and committed

## Local Testing

### 1. Build Backend Locally

```bash
# From project root
bun install
bun run build

# Run backend in development mode
cd backend
bun run dev
```

The backend should start on `http://localhost:3001`

### 2. Health Check

```bash
curl http://localhost:3001/health
```

Expected response:
```json
{
  "status": "ok",
  "timestamp": "2024-01-01T12:00:00.000Z",
  "uptime": 45,
  "database": true,
  "walrus": false
}
```

### 3. Test Authentication Flow

```bash
# Request challenge
curl -X POST http://localhost:3001/auth/challenge \
  -H "Content-Type: application/json" \
  -d '{"address":"0x123..."}' | jq

# Verify signature (with signed message)
curl -X POST http://localhost:3001/auth/verify \
  -H "Content-Type: application/json" \
  -d '{
    "address":"0x123...",
    "signature":"base64...",
    "nonce":"...",
    "message":"..."
  }' | jq
```

## Railway Deployment

### 1. Create Railway Project

```bash
# Login to Railway
railway login

# Create new project
railway init

# Select SONAR project (or create new)
```

### 2. Add PostgreSQL Database

```bash
# Add Postgres plugin
railway add

# Select PostgreSQL from available plugins
```

This creates a `Postgres` service with `DATABASE_URL` environment variable.

### 3. Set Backend Environment Variables

```bash
# Generate JWT_SECRET
bun run backend/scripts/setup.ts

# Set environment variables in Railway
railway variables set JWT_SECRET="<generated-secret>"
railway variables set LOG_LEVEL="info"
railway variables set SONAR_PACKAGE_ID="0x0"  # Set to actual contract ID
railway variables set SONAR_MARKETPLACE_ID="0x0"  # Set to actual object ID
railway variables set SUI_RPC_URL="https://fullnode.testnet.sui.io"
railway variables set WALRUS_RPC_URL="https://aggregator.walrus.network"
railway variables set CORS_ORIGIN="https://your-frontend-domain.com"
```

### 3a. Frontend Blockchain Configuration

The frontend now talks directly to the blockchain. Make sure these **public** environment variables are set **before building** the Next.js app:

| Variable | Description | Suggested Source |
| --- | --- | --- |
| `NEXT_PUBLIC_PACKAGE_ID` | Published SONAR Move package | `contracts/deployments/<network>.json` → `packageId` |
| `NEXT_PUBLIC_MARKETPLACE_ID` | Shared `QualityMarketplace` object ID | `contracts/deployments/<network>.json` → `objects.marketplace` |
| `NEXT_PUBLIC_STATS_OBJECT_ID` | (Optional) Marketplace object for stats queries | same as `NEXT_PUBLIC_MARKETPLACE_ID` |
| `NEXT_PUBLIC_REWARD_POOL_ID` | Reward pool balance object (optional) | Manual lookup (not in JSON yet) |

> ℹ️ If the environment variables are omitted, the frontend will try to fall back to the values in `contracts/deployments/<network>.json` (testnet/mainnet). Missing IDs trigger a clear UI error message and **block wallet transactions** so users never sign against `0x0`.

Example for Vercel/Netlify:

```bash
vercel env add NEXT_PUBLIC_PACKAGE_ID 0x6e4a4e65ba20ead7cea8d6ef0ed4d5639afdfff259c6943f02cbce927b21ae89
vercel env add NEXT_PUBLIC_MARKETPLACE_ID 0xaa422269e77e2197188f9c8e47ffb3faf21c0bafff1d5d04ea9613acc4994bb4
```

### 4. Deploy Backend

```bash
# Deploy using Dockerfile
railway up

# Or deploy specific service
railway deploy --service backend
```

Monitor deployment logs:
```bash
railway logs -f
```

### 5. Configure Frontend CORS

Update `frontend/.env.production`:
```env
NEXT_PUBLIC_BACKEND_URL="https://your-railway-domain.up.railway.app"
```

Or set via Railway environment:
```bash
railway variables set NEXT_PUBLIC_BACKEND_URL="https://your-railway-domain.up.railway.app"
```

## Environment Configuration

### Required Variables

| Variable | Description | Example |
|----------|-------------|---------|
| `DATABASE_URL` | PostgreSQL connection string | `postgresql://...` |
| `JWT_SECRET` | 32-byte secret for JWT signing | Generated by setup script |
| `NODE_ENV` | Environment (production/development) | `production` |
| `PORT` | Backend port | `3001` |

### Optional Variables

| Variable | Description | Default |
|----------|-------------|---------|
| `LOG_LEVEL` | Logging level (trace/debug/info/warn/error) | `info` |
| `JWT_EXPIRES_IN` | Token expiration time | `24h` |
| `SONAR_PACKAGE_ID` | Sui Move package ID | `0x0` (mock) |
| `SONAR_MARKETPLACE_ID` | Marketplace object ID | `0x0` (mock) |
| `SUI_RPC_URL` | Sui RPC endpoint | `https://fullnode.testnet.sui.io` |
| `WALRUS_RPC_URL` | Walrus RPC endpoint | `https://aggregator.walrus.network` |
| `MOCK_WALRUS` | Mock Walrus for testing | `false` |
| `MOCK_SUI` | Mock Sui for testing | `false` |
| `CORS_ORIGIN` | CORS allowed origin | `*` |

## Database Setup

### 1. Run Migrations

```bash
# Run migrations against Railway database
DATABASE_URL="$RAILWAY_DATABASE_URL" bun prisma migrate deploy
```

Or via Railway CLI:
```bash
railway run "bun prisma migrate deploy"
```

### 2. Seed Data

```bash
# Seed with mock datasets
railway run "bun prisma db seed"
```

Check seeding status:
```bash
railway run "bun prisma db execute --stdin" < scripts/check-seed.sql
```

## Post-Deployment Verification

### 1. Backend Health

```bash
# Check backend status
curl https://your-railway-domain.up.railway.app/health

# Should return 200 OK with health data
```

### 2. Authentication Test

From a browser console or API client:

```javascript
// Request challenge
const challenge = await fetch('https://your-backend.railway.app/auth/challenge', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ address: '0x1234...' })
}).then(r => r.json());

console.log(challenge);
// { nonce: "...", message: "...", expiresAt: ... }
```

### 3. Frontend Integration

1. Deploy frontend to Vercel/Netlify
2. Update `NEXT_PUBLIC_BACKEND_URL` to Railway domain
3. Test wallet authentication flow:
   - Click "Connect Wallet"
   - Click "Authenticate"
   - Sign message in wallet
   - Verify JWT token in localStorage

### 4. Database Verification

```bash
# Connect to Railway Postgres
railway connect postgres

# Check tables
\dt

# Verify seed data
SELECT COUNT(*) FROM "Dataset";
SELECT * FROM "Dataset" LIMIT 5;
```

## Troubleshooting

### Health Check Returns "database": false

**Problem**: Database connection failing

**Solution**:
1. Verify `DATABASE_URL` is set correctly
2. Check PostgreSQL service is running: `railway logs -s postgres`
3. Run migrations: `railway run "bun prisma migrate deploy"`
4. Check firewall/security groups allow incoming connections

```bash
# Test database connection
railway run "bun" << 'EOF'
import { PrismaClient } from "@prisma/client"
const db = new PrismaClient()
try {
  await db.$queryRaw`SELECT 1`
  console.log("Database connected!")
} catch (error) {
  console.error("Database error:", error.message)
}
EOF
```

### Health Check Returns "walrus": false

**Problem**: Walrus connectivity issue

**Solution**:
1. Check `WALRUS_RPC_URL` is correct
2. Enable `MOCK_WALRUS=true` for testing
3. Verify network connectivity: `curl $WALRUS_RPC_URL/health`

### Authentication Fails

**Problem**: JWT verification or signature verification fails

**Symptoms**:
- `/auth/challenge` works but `/auth/verify` returns 401
- Logs show "Invalid signature"

**Solution**:
1. Verify `JWT_SECRET` is set correctly (shouldn't change between requests)
2. Check nonce hasn't expired (5-minute window)
3. Verify wallet signature verification in logs: `railway logs -s backend | grep -i signature`

### Out of Memory

**Problem**: Backend crashes with OOM error

**Solution**:
1. Increase Railway memory: `railway variables set RAILWAY_MEMORY_GB=1.0`
2. Check for memory leaks in Wavesurfer peak caching
3. Monitor: `railway logs -s backend --grep "memory"`

### Slow Response Times

**Problem**: API endpoints respond slowly

**Causes**:
- Database queries taking too long
- Walrus streaming latency
- Peak extraction overhead

**Debug**:
```bash
# Check request logs
railway logs -s backend --grep "duration"

# Check database performance
railway run "bun prisma db execute --stdin" < << 'EOF'
SELECT query, calls, mean_time FROM pg_stat_statements
ORDER BY mean_time DESC LIMIT 10;
EOF
```

## Monitoring and Logs

### View Logs

```bash
# Real-time logs
railway logs -f

# Specific service
railway logs -s backend -f

# Filter by severity
railway logs --grep "error" -f
```

### Trace IDs

All requests include a trace ID for debugging:

```bash
# Find logs for specific request
railway logs --grep "trace_id=abc123def"
```

### Database Monitoring

```bash
# Connect to database for inspection
railway connect postgres

# Check connection stats
SELECT datname, count(*) FROM pg_stat_activity GROUP BY datname;

# Kill long-running queries (if needed)
SELECT pg_terminate_backend(pid) FROM pg_stat_activity
WHERE datname='sonar' AND state='active' AND query_start < now() - interval '5 minutes';
```

## Rollback Procedure

```bash
# View deployment history
railway deployments

# Rollback to previous deployment
railway deployments rollback <deployment-id>

# Verify rollback
railway logs -f
```

## Cost Optimization

1. **Database**:
   - PostgreSQL on Railway: ~$5/month (free tier available)
   - Enable automated backups

2. **Storage**:
   - Walrus handles blob storage (external)
   - Minimal database storage for metadata

3. **Bandwidth**:
   - Stream directly from Walrus (not through backend)
   - Monitor preview caching hits

4. **Compute**:
   - Start with 512MB RAM
   - Scale up if needed based on traffic

## Security Checklist

- [ ] JWT_SECRET is 32+ bytes (generated with `bun run backend/scripts/setup.ts`)
- [ ] DATABASE_URL uses SSL connection (Railway Postgres default)
- [ ] CORS_ORIGIN restricted to frontend domain(s)
- [ ] SUI_RPC_URL uses official endpoint (not public unsecured endpoint)
- [ ] No sensitive data in logs (check `LOG_LEVEL=info`)
- [ ] Rate limiting enabled (configured in `backend/src/index.ts`)
- [ ] HTTPS enforced (Railway auto-provides HTTPS)
- [ ] Health endpoint doesn't expose sensitive data

## Next Steps

After deployment:

1. Test full authentication flow with live wallet
2. Verify preview audio caching works
3. Test purchase and access grant flow
4. Load test with expected traffic patterns
5. Set up monitoring and alerting
6. Document custom domain setup
7. Configure CI/CD pipeline for auto-deploy

For frontend deployment and integration, see [Frontend Deployment Guide](./FRONTEND_DEPLOYMENT.md).
